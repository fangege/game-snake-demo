# 前言

最为一个互联网业务后台开发，对网络中游戏角色能在多个终端显示感到非常的神奇，查询网络中的资料后理解到网络同步和分布式系统中的状态一致性有异曲同工之处。


# 概念
网络同步的目标就是时刻保证多台机器的游戏表现完全一致。
1. 游戏状态数据：描述游戏中角色的参数，例如位置、方向等，通过显示逻辑渲染到显示设备上。在贪食蛇游戏中用来描述蛇的位置、方向、长度、速度等，游戏状态数据通过渲染直接便是玩家通过显示器看到的画面。
2. 事件： 用户对游戏的操作事件以及其他影响游戏状态得事件。贪食蛇游戏中用户操作仅包含控制贪食蛇的上下左右
3. 游戏控制器：根据用户的指令事件和其它事件更新游戏状态数据 。贪食蛇游戏中，游戏逻辑根据用户的指令控制游戏方向，并定时生成食物，判断贪食蛇吃食物和计算贪食蛇新位置

网络游戏和互联网中的分布式系统有一个相同的问题，就是如何保证系统数据状态在多个节点中保持一致。解决方案的思想也一致，就是对影响数据状态的事件进行排序，只要系统起始状态和事件发生的顺序一致，则系统最终状态也会一致。分布式系统使用了统一时钟如逻辑时钟和向量时钟来对事件排序，而网络游戏则让事件的排序在同一个节点(主机或者服务器)。

## 主机游戏
最单机情况下例如小霸王、街机等，两个玩家使用同一台游戏主机，没有网络同步，游戏控制器根据手柄外设上传的用户操作直接更新游戏状态数据。因为使用单机，所以影响游戏事件的操作都在机器内存中排序，不会有数据不一致的问题。

![image.png](https://km.woa.com/asset/00010002240900f73748139e2f441601?height=627&width=1010)

贪食蛇单机代码见：[贪食蛇单机演示项目](https://github.com/fangege/game-snake-demo/blob/master/html/snake.html) 实现代码在 html 目录下的 snake.html,该代码使用 chatGpt3.5 生成，直接在浏览器中打开即可运行。该代码实现了一个 web 端的双人简单贪食蛇游戏，player1 使用wsad键控制蛇的方向,player2 使用方向键，食物会随机产生。
代码的实现 input->stateCompute->state->view的模型，用户通过输入改变游戏状态，游戏状态数据体现到游戏 ui 上。

![单机.gif](https://km.woa.com/asset/00010002240900aadd65564976457a03?height=338&width=600)

## 状态同步

### 局域网游戏
早期网吧老板舍不得开拨线上网的时候，玩家经常玩局域网游戏，通常是一个玩家建立主机，其他玩家加入游戏，当主机掉线时整个游戏暂停或者结束，但从机掉线不影响其他玩家。这种模式可以理解为建主机时建了一个游戏控制中心，所有玩家的操作指令通过局域网传输到主机的控制中心进行排序，游戏控制逻辑按顺序根据所有玩家指令事件计算得到游戏状态数据，客户端定时将玩家可见的状态数据同步到玩家设备上并显示给用户。
![image.png](https://km.woa.com/asset/00010002240900db9b94100a424ec201?height=879&width=999)

这是一种典型的 C/S 结构，网络同步也不限制在局域网中，互联网通过虚拟机局域网技术也可以采用这种模式(各种对战平台的做法)。这种模式的优点在于不需要架设服务器，缺点是缺乏公平性性，主机玩家有更短的时延，更高的可靠性；同时游戏数据和控制判定都在主机中，也让主机玩家能更方便的进行作弊。


### 网络游戏

架设中心服务器后可以很大程度解决公平性问题，将游戏控制器和游戏状态数据都迁移到中心服务器中，所有玩家的操作都通过网络传输到游戏服务器，服务器运行的游戏控制逻辑根据玩家指令计算更新全局玩家数据，玩家客户端程序定时将玩家可见的游戏状态同步主机中并渲染显示给玩家。

![image.png](https://km.woa.com/asset/000100022409000e46800a78b7446e01?height=818&width=1403)

在单机版的贪食蛇基础上，添加了[后台服务器](https://github.com/fangege/game-snake-demo/blob/master/server/stat_sync/app.js), [客户端](https://github.com/fangege/game-snake-demo/blob/master/server/stat_sync/index.ejs)请求 `/event`上传玩家控制贪食蛇方向的操作，定时请求`/state`刷新游戏状态。

状态同步实现简单且安全性较好，但也有两个问题:
1. 当游戏单位较多时，表达游戏状态的同步数据包过大可能导致带宽浪费。
2. 逻辑计算都负载服务端，客户端性能浪费，服务端压力大。
3. 前后端都得理解游戏逻辑，影响开发效率。



## 帧同步

基于状态同步缺点，很容易想到可以让客户端自己计算游戏逻辑，而所有玩家得指令都广播到其他玩家，这就是帧同步概念。帧同步虽然游戏状态的计算是在各个客户端中，但影响游戏状态的事件统一由主机或者中心服务器来排序，所有终端执行的是同样顺序的事件，最后的计算得到的游戏状态数据也会一致。

![image.png](https://km.woa.com/asset/000100022409005d0c5d5ce9f6448c01?height=847&width=1755)


贪食蛇游戏中的帧同步中，[客户端](https://github.com/fangege/game-snake-demo/blob/master/server/lock_step_http/index.ejs)将事件上报到服务器，然后定期从服务器中获取事件队列，计算后更新游戏中贪食蛇的位置、长度，[服务器](https://github.com/fangege/game-snake-demo/blob/master/server/lock_step_http/app.js)只负责将指令按顺序保存到队列中。要注意的是，游戏中食物随机位置需要在多端中保持一致，要么由服务器生成随机数，要么客户端使用伪随机数保证多端每次随机数都是一致。

## 客户端预测

### 技术背景

在实时动作游戏中，网络延迟成为影响游戏体验的关键因素。传统的状态同步和帧同步虽然能保证数据一致性，但都需要等待网络通信，导致操作延迟感明显。

以100ms网络延迟为例：
- 状态同步：玩家按键 → 100ms → 服务端处理 → 100ms → 客户端显示 = 200ms延迟
- 帧同步：玩家按键 → 100ms → 广播到其他客户端 → 本地计算 = 100ms延迟  
- 客户端预测：玩家按键 → 立即显示 → 后台校正 = 0ms延迟感

客户端预测技术通过在本地立即执行操作，然后与服务端进行校正，实现了接近零延迟的游戏体验。这是目前大多数实时多人游戏（如FPS、MOBA、竞速游戏）采用的核心同步技术。

![image.png](https://km.woa.com/asset/000100022409005d0c5d5ce9f6448c01?height=847&width=1755)

### 核心机制

客户端预测系统包含四个关键组件：

1. **立即响应**：玩家输入立即在客户端生效，无需等待服务端确认
2. **预测计算**：客户端运行与服务端相同的游戏逻辑进行预测
3. **状态校正**：服务端定期发送权威状态，客户端进行必要的校正
4. **回滚重放**：当预测错误时，回滚到正确状态并重新应用后续输入

```javascript
// 简化的客户端预测示例
class ClientPrediction {
    constructor() {
        this.localState = {};
        this.inputBuffer = [];
        this.sequence = 0;
    }
    
    // 1. 处理玩家输入
    handleInput(input) {
        // 立即应用到本地状态
        this.localState = this.applyInput(this.localState, input);
        
        // 记录输入用于可能的回滚
        this.inputBuffer.push({
            sequence: this.sequence++,
            input: input,
            timestamp: Date.now()
        });
        
        // 发送到服务端
        this.sendToServer(input);
    }
    
    // 2. 处理服务端状态更新
    handleServerUpdate(serverState) {
        // 检查是否需要校正
        if (this.needsCorrection(serverState)) {
            this.correctState(serverState);
        }
    }
}
```

### 坦克大战演示

为了展示客户端预测技术在实际游戏中的应用，项目实现了一个完整的坦克大战演示。

**技术特性**：
- 实时移动和转向控制
- 即时射击反馈
- 客户端预测 + 服务端校正
- 网络延迟补偿
- 反作弊验证机制

**访问方式**：

1. **单机版本**：直接打开 `html/tank_battle.html`
   - 用于理解基础游戏机制
   - 无网络延迟，操作即时响应

2. **网络版本**：启动服务器后访问 `http://localhost:3003/tank_battle`
   ```bash
   # 启动坦克大战服务器
   node server/tank_battle/app.js
   ```
   - 展示完整的客户端预测系统
   - 支持双人实时对战
   - 包含网络监控面板

**控制说明**：
- W/S：前进/后退
- A/D：左转/右转
- 空格：射击

**演示对比**：
可以通过调整网络延迟模拟，对比不同同步技术的用户体验：
- 关闭预测：明显的操作延迟
- 开启预测：流畅的即时响应

![坦克大战.gif](https://km.woa.com/asset/00010002240900aadd65564976457a03?height=338&width=600)

## 技术对比总结

### 同步技术全面对比

| 特性 | 状态同步 | 帧同步 | 客户端预测 |
|------|----------|--------|------------|
| **实现复杂度** | 低 | 中 | 高 |
| **网络带宽消耗** | 高 | 低 | 中 |
| **延迟感知** | 明显 | 明显 | 极低 |
| **数据安全性** | 高 | 中 | 高 |
| **服务端压力** | 高 | 低 | 中 |
| **客户端性能要求** | 低 | 中 | 高 |
| **断线恢复** | 简单 | 复杂 | 中等 |
| **适用游戏类型** | 回合制、策略 | RTS、MOBA | FPS、动作 |
| **典型应用** | 贪食蛇、棋牌 | 星际争霸 | CS、王者荣耀 |

### 技术选择建议

**选择状态同步的场景**：
- 回合制游戏（棋牌、策略）
- 对实时性要求不高的游戏
- 开发资源有限的小型项目
- 对数据一致性要求极高的场景

**选择帧同步的场景**：
- RTS游戏（即时战略）
- 需要精确同步的竞技游戏
- 玩家数量较少（<10人）的游戏
- 对带宽成本敏感的项目

**选择客户端预测的场景**：
- FPS、TPS等射击游戏
- MOBA、动作游戏
- 对操作响应性要求极高的游戏
- 大型多人在线游戏

### 混合方案

实际项目中，往往会结合多种技术：
- **核心操作**使用客户端预测（移动、射击）
- **重要事件**使用状态同步（生命值、得分）
- **环境元素**使用帧同步（天气、NPC）

# 参考文献
1. [浅析帧同步和状态同步](https://zhuanlan.zhihu.com/p/357973435)
2. [做个几万人一起玩的《荒野大镖客》有可能吗？](https://zhuanlan.zhihu.com/p/210308844)
3. [帧同步：原理与实现](https://zhuanlan.zhihu.com/p/556920018)
4. [2 天做了个多人实时对战，200ms 延迟竟然也能丝滑流畅？](https://juejin.cn/post/7041560950897377293)
5. [Client-Side Prediction and Server Reconciliation](https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html)
6. [Fast-Paced Multiplayer (Part I): Client-Server Game Architecture](https://www.gabrielgambetta.com/client-server-game-architecture.html)
7. [Networked Physics in Virtual Worlds](https://gafferongames.com/post/networked_physics_2004/)
8. [客户端预测与服务端校正技术详解](https://zhuanlan.zhihu.com/p/38468615)
